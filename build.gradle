// Applies BrazilGradle plugin then uses it to setup the build script classpath.
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
buildscript {
    dependencies {
        classpath brazilGradle.tool('BrazilGradleQualityDefaults')
        classpath brazilGradle.tool('GradleShadow')
        classpath brazilGradle.tool('ProGuard')
    }
}

/*
 Applies core Gradle plugins, which are ones built into Gradle itself.
*/
plugins {
    // Java for compile and unit test of Java source files. Read more at:
    // https://docs.gradle.org/current/userguide/java_plugin.html
    id 'java'

    // Checkstyle for style checks and reports on Java source files. Read more at:
    // https://docs.gradle.org/current/userguide/checkstyle_plugin.html
    //id 'checkstyle'

    // JaCoCo for coverage metrics and reports of Java source files. Read more at:
    // https://docs.gradle.org/current/userguide/jacoco_plugin.html
    //id 'jacoco'
}

/*
 Applies community Gradle plugins, usually added as build-tools in Config.
*/

// SpotBugs for quality checks and reports of source files. Read more at:
// https://spotbugs.readthedocs.io/en/stable/gradle.html
//apply plugin: 'com.github.spotbugs'

apply plugin: 'com.github.johnrengelman.shadow'

/*
 Java plugin default project layout is 'src/main/java' and 'src/test/java'.
 Uncomment below if you instead want to use 'src' and 'tst'.

sourceSets.main.java.srcDirs = ['src']
sourceSets.test.java.srcDirs = ['tst']
*/

/*
 Configures the Checkstyle "checkstyle" plugin. Remove this and the plugin if
 you want to skip these checks and report generation.
*/
//checkstyle {
//    sourceSets = [sourceSets.main]
//    ignoreFailures = false
//    def suppressionFile = file("checkstyle-suppressions.xml")
//    configProperties.put('checkstyle.suppression.filter', suppressionFile)
//}

/*
 Configures the JaCoCo "jacoco" plugin. Remove this if you want to skip
 these checks and report generation.

 Set minimum code coverage to fail build, where 0.01 = 1%.
*/

def excludedFiles = [
]
//
//check.dependsOn jacocoTestCoverageVerification
//        jacocoTestCoverageVerification {
//            violationRules {
//                afterEvaluate {
//                    getClassDirectories().setFrom(classDirectories.files.collect {
//                        fileTree(dir: it, exclude: excludedFiles)
//                    })
//                }
//                rule {
//                    limit {
//                        minimum = 0.68
//                    }
//                }
//            }
//        }
//
//// Configures JaCoCo Coverage report.
//coverageReport {
//    reports {
//        html.enabled true
//        xml.enabled true
//    }
//    afterEvaluate {
//        classDirectories.from = files(classDirectories.files.collect {
//            fileTree(dir: it, exclude: excludedFiles)
//        })
//    }
//}

/*
 Configures the SpotBugs "com.github.spotbugs" plugin. Remove this and the
 plugin to skip these checks and report generation.
*/
//spotbugs {
//    excludeFilter.set(file("spotbugs-exclude.xml"))
//    ignoreFailures.set(false)
//}
/*
  The SpotBugs Gradle Plugin generates a task for each sourceSet generated by
  Gradle Java Plugin. For instance, if you have two sourceSets main and test,
  this plugin will generates two tasks: spotbugsMain and spotbugsTest.
  Uncomment below if you want to skip checks for test code.

spotbugsTest {
  ignoreFailures = true
}
*/

/*
 Resolve build, test, tool, and runtime dependencies using BrazilGradle.
*/
dependencies {
    runtimeOnly brazilGradle.run()
    compile brazilGradle.build()
    testImplementation brazilGradle.testbuild()
    compileOnly brazilGradle.tool('Lombok')
    annotationProcessor brazilGradle.tool('Lombok')
    testCompileOnly brazilGradle.tool('Lombok') // If you need Lombok in unit tests
    testAnnotationProcessor brazilGradle.tool('Lombok') // If you need Lombok in unit tests
}

/*
 Specifies that JUnit Platform (a.k.a. JUnit 5) should be used to execute tests.

 For mixed JUnit 4 and 5 tests, add 'JUnit-4-12-migration = 5.x;' to
 test-dependencies in Config.
*/
test {
    useJUnitPlatform()
}

apply plugin: 'application'
mainClassName = 'src.main.java.com.amazon.limitless.assessment.SampleJavaClass'

// don't build the regular jar, we'll build the uber jar only i.e. the fat jar with all the dependencies
//jar.enabled = false
//build.dependsOn shadowJar
shadowJar.enabled = false

/*shadowJar {
  //setting classifer to empty will not append `all` to uber jar name
  archiveClassifier.set('')
  destinationDirectory = file("${brazilGradle.path('package-build-root')}/lib/artifacts/${brazilGradle.path('package-major-version')}/")
//    archiveFileName = "artifacts/${brazilGradle.path('package-major-version')}/" +
//            "${brazilGradle.path('package-name')}-${brazilGradle.path('package-major-version')}.jar"
  manifest {
    attributes 'Multi-Release': 'true'
  }
}*/

task copyConfiguration(type: Copy) {
    from "${project.projectDir}/configuration"
    into brazilGradle.buildDir
}

build.dependsOn copyConfiguration

        task obfuscate(type: proguard.gradle.ProGuardTask) {
    // You should probably import a more compact ProGuard-style configuration
    // file for all static settings, but we're specifying them all here, for
    // the sake of the example.
    //configuration 'configuration.pro'

    verbose

    // Specify the input jars, output jars, and library jars.
    injars jar
            outjars "${buildDir}/libs/${rootProject.name}-obfuscated.jar"

    // Automatically handle the Java version of this build.
    if (System.getProperty('java.version').startsWith('1.')) {
        // Before Java 9, the runtime classes were packaged in a single jar file.
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        // As of Java 9, the runtime classes are packaged in modular jmod files.
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.getProperty('java.home')}/jmods/java.desktop.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        //libraryjars "${System.getProperty('java.home')}/jmods/....."

    }
    libraryjars files(configurations.compile.collect())

    // Save the obfuscation mapping to a file, so you can de-obfuscate any stack
    // traces later on. Keep a fixed source file attribute and all line number
    // tables to get line numbers in the stack traces.
    // You can comment this out if you're not interested in stack traces.

    /*printmapping 'out.map'
    renamesourcefileattribute 'SourceFile'
    keepattributes 'SourceFile,LineNumberTable'*/
    // Preserve all annotations.
    keepattributes '*Annotation*'

    // You can print out the seeds that are matching the keep options below.
    //printseeds 'out.seeds'

    // Preserve all public applications.
    keepclasseswithmembers 'public class * { \
    public static void main(java.lang.String[]); \
}'

// Preserve all native method names and the names of their classes.
keepclasseswithmembernames includedescriptorclasses: true, 'class * { \
native <methods>; \
}'

// Preserve the special static methods that are required in all enumeration
// classes.
keepclassmembers 'enum * { \
public static **[] values(); \
public static ** valueOf(java.lang.String); \
}'

keepclassmembers 'enum * { *; }'

// Explicitly preserve all serialization members. The Serializable interface
// is only a marker interface, so it wouldn't save them.
// You can comment this out if your application doesn't use serialization.
// If your code contains serializable classes that have to be backward
// compatible, please refer to the manual.

keepclassmembers 'class * implements java.io.Serializable { \
static final long serialVersionUID; \
static final java.io.ObjectStreamField[] serialPersistentFields; \
private void writeObject(java.io.ObjectOutputStream); \
private void readObject(java.io.ObjectInputStream); \
java.lang.Object writeReplace(); \
java.lang.Object readResolve(); \
}'

keep 'class org.apache.**'

dontwarn 'org.apache.**'
}

task fatJar(type: ShadowJar) {
from obfuscate
configurations = [project.configurations.compile]
//setting classifer to empty will not append `all` to uber jar name
archiveClassifier.set('')
destinationDirectory = file("${brazilGradle.path('package-build-root')}/lib/artifacts/${brazilGradle.path('package-major-version')}/")
//version =
manifest {
attributes 'Main-Class': 'com.amazon.limitless.assessment.LimitlessCompatibilityAssessmentTool', 'Multi-Release': 'true'
}
}

build.dependsOn fatJar
